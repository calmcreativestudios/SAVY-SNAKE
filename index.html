<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Snake</title>
<style>
  html, body { margin:0; padding:0; height:100%; background:#fff; overflow:hidden; }
  #wrap { position:relative; width:100%; height:100%; }
  canvas { display:block; width:100%; height:100%; background:#000; }

  /* Simple HUD */
  #hud {
    position:absolute; left:16px; top:14px;
    font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    color:#fff; font-size:14px; line-height:1.2;
    user-select:none; pointer-events:none;
    text-shadow: 0 1px 2px rgba(0,0,0,0.35);
  }
  #hud strong { font-weight:700; }

  /* Center messages */
  #centerMsg {
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center;
    text-align:center;
    font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    color:#fff;
    user-select:none; pointer-events:none;
    padding:24px;
  }
  #centerMsg .box{
    max-width:520px;
    font-size:16px;
    line-height:1.35;
    text-shadow: 0 2px 8px rgba(0,0,0,0.55);
  }
  #centerMsg .big { font-size:22px; font-weight:800; letter-spacing:0.5px; }
  #centerMsg .sub { opacity:0.9; margin-top:10px; }
  #centerMsg .hint { opacity:0.85; margin-top:14px; font-size:14px; }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <div id="hud">
    <div><strong>Score:</strong> <span id="scoreTxt">0</span></div>
    <div style="opacity:.85"><strong>Unlock:</strong> <span id="unlockTxt">22</span> / <span id="milestoneTxt">100</span></div>
  </div>

  <div id="centerMsg">
    <div class="box" id="msgBox">
      <div class="big" id="msgTitle">SNAKE</div>
      <div class="sub" id="msgSub">Press any arrow key to start</div>
      <div class="hint" id="msgHint">R or Space to restart</div>
    </div>
  </div>
</div>

<script>
(() => {
  // --------------------------
  // Settings
  // --------------------------
  const UNLOCK_SCORE = 22;
  const MILESTONE_SCORE = 100;

  // Grid-based snake (stable visuals across resizes)
  const GRID_COLS = 28;
  const GRID_ROWS = 28;

  // Speed tuning
  const BASE_TPS = 10; // ticks per second

  // Colors
  const COL_BG = "#000";
  const COL_SNAKE = "#00ff7b";
  const COL_FOOD = "#ff3b30";
  const COL_TEXT = "#ffffff";

  // --------------------------
  // Canvas setup (HiDPI)
  // --------------------------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  function resizeCanvas() {
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width));
    const h = Math.max(1, Math.floor(rect.height));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  window.addEventListener("resize", resizeCanvas, { passive: true });
  resizeCanvas();

  // --------------------------
  // UI Elements
  // --------------------------
  const scoreTxt = document.getElementById("scoreTxt");
  const centerMsg = document.getElementById("centerMsg");
  const msgTitle = document.getElementById("msgTitle");
  const msgSub = document.getElementById("msgSub");
  const msgHint = document.getElementById("msgHint");

  function showCenter(title, sub, hint) {
    msgTitle.textContent = title;
    msgSub.textContent = sub || "";
    msgHint.textContent = hint || "";
    centerMsg.style.display = "flex";
  }
  function hideCenter() {
    centerMsg.style.display = "none";
  }

  // --------------------------
  // Audio (safe)
  // --------------------------
  const eatSound = new Audio("eat.mp3");
  const unlockSound = new Audio("unlock.mp3");
  eatSound.preload = "auto";
  unlockSound.preload = "auto";
  eatSound.volume = 0.8;
  unlockSound.volume = 0.9;

  // Browsers require user gesture. We'll "arm" audio on first key press.
  let audioArmed = false;
  function armAudioOnce() {
    if (audioArmed) return;
    audioArmed = true;

    // Attempt silent/quick play to unlock audio pipeline
    try {
      eatSound.muted = true;
      const p = eatSound.play();
      if (p && typeof p.then === "function") {
        p.then(() => {
          eatSound.pause();
          eatSound.currentTime = 0;
          eatSound.muted = false;
        }).catch(() => {
          eatSound.muted = false;
        });
      } else {
        eatSound.pause();
        eatSound.currentTime = 0;
        eatSound.muted = false;
      }
    } catch (e) {}
  }

  function playSound(aud) {
    try {
      aud.currentTime = 0;
      const p = aud.play();
      if (p && typeof p.catch === "function") p.catch(() => {});
    } catch (e) {}
  }

  // --------------------------
  // Game state
  // --------------------------
  let snake, dir, nextDir, food, score, alive, started;
  let unlockFlashT = 0;

  function resetGame() {
    const startX = Math.floor(GRID_COLS / 2);
    const startY = Math.floor(GRID_ROWS / 2);

    snake = [
      { x: startX, y: startY },
      { x: startX - 1, y: startY },
      { x: startX - 2, y: startY }
    ];

    dir = { x: 1, y: 0 };
    nextDir = { x: 1, y: 0 };

    score = 0;
    alive = true;
    started = false;
    unlockFlashT = 0;

    placeFood();
    scoreTxt.textContent = String(score);

    showCenter("SNAKE", "Press any arrow key to start", "R or Space to restart");
  }

  function placeFood() {
    // Pick random empty cell
    while (true) {
      const fx = Math.floor(Math.random() * GRID_COLS);
      const fy = Math.floor(Math.random() * GRID_ROWS);
      const onSnake = snake.some(s => s.x === fx && s.y === fy);
      if (!onSnake) { food = { x: fx, y: fy }; return; }
    }
  }

  function kill() {
    alive = false;
    showCenter("GAME OVER", "Press R or Space to restart", "");
  }

  // "Unlock UI" hook (kept simple)
  function unlockUI() {
    // Keep your existing behavior here if you want later (text, effects, etc.)
    // For now we just show a message for a moment by flashing.
  }

  // --------------------------
  // Input
  // --------------------------
  function setDir(dx, dy) {
    // Prevent reversing into itself
    if (dx === -dir.x && dy === -dir.y) return;
    nextDir = { x: dx, y: dy };
    if (!started && alive) {
      started = true;
      hideCenter();
    }
  }

  window.addEventListener("keydown", (e) => {
    const k = e.key;

    // Arm audio on first interaction
    armAudioOnce();

    if (k === "ArrowUp") { e.preventDefault(); setDir(0, -1); }
    else if (k === "ArrowDown") { e.preventDefault(); setDir(0, 1); }
    else if (k === "ArrowLeft") { e.preventDefault(); setDir(-1, 0); }
    else if (k === "ArrowRight") { e.preventDefault(); setDir(1, 0); }
    else if (k === "r" || k === "R" || k === " ") {
      e.preventDefault();
      resetGame();
    }
  }, { passive: false });

  // --------------------------
  // Ticking
  // --------------------------
  let lastTime = 0;
  let acc = 0;
  const tickLen = 1000 / BASE_TPS;

  function tick() {
    if (!alive || !started) return;

    dir = nextDir;

    const head = snake[0];
    let nx = head.x + dir.x;
    let ny = head.y + dir.y;

    // Wrap (you can change to wall death if you prefer)
    if (nx < 0) nx = GRID_COLS - 1;
    if (nx >= GRID_COLS) nx = 0;
    if (ny < 0) ny = GRID_ROWS - 1;
    if (ny >= GRID_ROWS) ny = 0;

    // Self collision
    if (snake.some((s, i) => i > 0 && s.x === nx && s.y === ny)) {
      kill();
      return;
    }

    // Move: add head
    snake.unshift({ x: nx, y: ny });

    // Eat
    if (nx === food.x && ny === food.y) {
      score++;
      scoreTxt.textContent = String(score);

      // Eat sound
      playSound(eatSound);

      // Unlock checks (sound at 22 + 100)
      if (score === UNLOCK_SCORE) {
        unlockUI();
        unlockFlashT = 650;

        playSound(unlockSound);
      } else if (score === MILESTONE_SCORE) {
        // milestone
        playSound(unlockSound);
      } else if (score > UNLOCK_SCORE) {
        unlockUI();
      }

      placeFood();
    } else {
      // normal move: remove tail
      snake.pop();
    }

    if (unlockFlashT > 0) unlockFlashT -= tickLen;
  }

  // --------------------------
  // Render
  // --------------------------
  function draw() {
    const rect = canvas.getBoundingClientRect();
    const W = rect.width;
    const H = rect.height;

    // Compute cell size and center the grid
    const cell = Math.floor(Math.min(W / GRID_COLS, H / GRID_ROWS));
    const gridW = cell * GRID_COLS;
    const gridH = cell * GRID_ROWS;
    const ox = Math.floor((W - gridW) / 2);
    const oy = Math.floor((H - gridH) / 2);

    // Clear
    ctx.fillStyle = COL_BG;
    ctx.fillRect(0, 0, W, H);

    // Food
    ctx.fillStyle = COL_FOOD;
    ctx.fillRect(ox + food.x * cell, oy + food.y * cell, cell, cell);

    // Snake
    ctx.fillStyle = COL_SNAKE;
    for (let i = 0; i < snake.length; i++) {
      const s = snake[i];
      ctx.fillRect(ox + s.x * cell, oy + s.y * cell, cell, cell);
    }

    // Unlock flash overlay (subtle)
    if (unlockFlashT > 0) {
      const t = Math.max(0, Math.min(1, unlockFlashT / 650));
      ctx.fillStyle = `rgba(255,255,255,${0.18 * t})`;
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = COL_TEXT;
      ctx.font = "700 18px -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ENTER SHOP UNLOCKED", W / 2, oy + gridH + 28);
    } else if (score >= UNLOCK_SCORE) {
      // Keep a small hint if unlocked
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.font = "700 16px -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ENTER SHOP", W / 2, oy + gridH + 26);
    }
  }

  function loop(ts) {
    if (!lastTime) lastTime = ts;
    const dt = ts - lastTime;
    lastTime = ts;
    acc += dt;

    while (acc >= tickLen) {
      tick();
      acc -= tickLen;
    }

    draw();
    requestAnimationFrame(loop);
  }

  // Start
  resetGame();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
