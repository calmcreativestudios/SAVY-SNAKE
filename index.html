<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Savy Snake Module</title>

  <!-- Source Sans Pro -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#ffffff;
      --ink:#000000;
      --game:#000000;
      --ui:#000000;

      /* Layout sizing (the “design canvas” size) */
      --gameSize: 900px;
      --gap: 48px;
      --sideMin: 220px;
    }
/* =========================
   DESKTOP LAYOUT (DEFAULT)
   ========================= */

#savySnakeModule {
  display: flex;
  align-items: flex-start;
  justify-content: center;
  gap: 16px;
  width: 100%;
  box-sizing: border-box;
}

.gameBox {
  flex: 0 0 auto;
}

/* game canvas behaviour on desktop */
#game {
  width: 100%;
  max-width: 900px;
  height: auto;
  display: block;
}

/* score + password */
.sideUI {
  width: 260px;
  flex-shrink: 0;
}

/* =========================
   SMALL DESKTOP / NARROW PREVIEW
   ========================= */
@media (max-width: 1200px) {
  #savySnakeModule {
    flex-direction: column;
  }

  .sideUI {
    width: 100%;
  }
}

    html,body{
      margin:0; padding:0;
      width:100%;
      height:100%;
      background:var(--bg);
      color:var(--ui);
      font-family:"Source Sans Pro",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      overflow-x: hidden;
overflow-y: visible;

    }

    #stage{
      position:fixed;
      left:0;
      top:0;
      transform-origin: 0 0;
      will-change: transform;
    }

    .savy-snake{
      display:flex;
      align-items:flex-start;
      gap:var(--gap);
      background:transparent;
    }

    .gameBox{
      width:var(--gameSize);
      height:var(--gameSize);
      background:var(--game);
      border:6px solid var(--ink);
      box-sizing:border-box;
      display:grid;
      place-items:center;
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
      background:transparent;
      image-rendering: pixelated; /* keep snake pixel style */
      touch-action:none;
    }

    .sideUI{
      min-width:var(--sideMin);
      padding-top:8px;
      user-select:none;
    }

    .score{
      font-size:16px;
      letter-spacing:0.5px;
      text-transform:uppercase;
      font-weight:400;
    }

    .enterShop{
      margin-top:44px;
      font-size:16px;
      letter-spacing:0.5px;
      text-transform:uppercase;
      font-weight:400;
      opacity:0;
      pointer-events:none;
      transition:opacity 180ms linear;
      cursor:pointer;
      display:inline-block;
    }

    .enterShop.unlocked{
      opacity:1;
      pointer-events:auto;
    }

    .enterShop.flash{ animation: flash 0.65s linear 1; }
    @keyframes flash{
      0%{opacity:0.15;}
      12%{opacity:1;}
      24%{opacity:0.15;}
      36%{opacity:1;}
      48%{opacity:0.15;}
      60%{opacity:1;}
      100%{opacity:1;}
    }
    /* === LAYOUT WRAPPER === */
#savySnakeModule {
  display: flex;
  align-items: flex-start;
  gap: 16px;
}

/* game area */
.gameBox {
  flex: 1;
}

/* score + password */
.sideUI {
  width: 260px;
}

/* canvas responsive fix */
#game {
  max-width: 100%;
  height: auto;
}
/* prevent page scroll on touch */
html, body {
  overscroll-behavior: none;
}

#game {
  touch-action: none;
}

/* === MOBILE === */
@media (max-width: 768px) {
  #savySnakeModule {
    flex-direction: column;
  }

  .sideUI {
    width: 100%;
  }
    /* mobile readability tweak */
  .score,
  .enterShop {
    font-size: 14px;
    line-height: 1.3;
  }
}
  </style>
</head>
<body>

  <div id="stage">
    <div class="savy-snake" id="savySnakeModule">
      <div class="gameBox" aria-label="Savy Snake game">
        <canvas id="game" width="900" height="900"></canvas>
      </div>

      <div class="sideUI">
        <div class="score" id="scoreText">SCORE: 00</div>
        <div class="enterShop" id="enterShop">PASSWORD: SAVYSAYNOTHING</div>
      </div>
    </div>
  </div>

<script>
(() => {
  /***********************
   * SETTINGS
   ***********************/
  const UNLOCK_SCORE = 11;
  const DISCOUNT_SCORE = 100; // later
  const SHOP_URL = ""; // optional redirect later

  const GRID = 28;
  const START_MS = 80;
  const MIN_MS = 52;
  const SPEEDUP_EVERY = 4;
  const SPEEDUP_MS = 4;

  // Make logo (food) larger to keep it visually clean + readable
  const FOOD_SCALE_TO_CELL = 2.6; // was 1.6

  const LOGO_SRC = "./savy-logo.svg";
    /***********************
   * SOUND
   ***********************/
  const EAT_SFX_SRC = "./eat.mp3";
  const UNLOCK_SFX_SRC = "./unlock.mp3";
  const START_SFX_SRC = "./START.mp3";
const LOSE_SFX_SRC  = "./LOSE.mp3";


  const eatSfx = new Audio(EAT_SFX_SRC);
  const unlockSfx = new Audio(UNLOCK_SFX_SRC);
  const startSfx = new Audio(START_SFX_SRC);
const loseSfx  = new Audio(LOSE_SFX_SRC);


  eatSfx.preload = "auto";
unlockSfx.preload = "auto";
startSfx.preload = "auto";
loseSfx.preload  = "auto";

// optional levels
eatSfx.volume = 0.5;
unlockSfx.volume = 0.5;
startSfx.volume = 0.5;
loseSfx.volume  = 0.5;

  // Browser audio policy: arm once on first user input
  let audioArmed = false;
  function armAudioOnce(){
    if (audioArmed) return;
    audioArmed = true;

    // try to unlock audio playback without audible output
    try {
      eatSfx.muted = true;
      const p = eatSfx.play();
      if (p && typeof p.then === "function") {
        p.then(() => {
          eatSfx.pause();
          eatSfx.currentTime = 0;
          eatSfx.muted = false;
        }).catch(() => {
          eatSfx.muted = false;
        });
      } else {
        eatSfx.pause();
        eatSfx.currentTime = 0;
        eatSfx.muted = false;
      }
    } catch(e) {}
  }

  function playSfx(a){
    try{
      a.currentTime = 0;
      const p = a.play();
      if (p && typeof p.catch === "function") p.catch(() => {});
    } catch(e) {}
  }

  /***********************
   * STAGE AUTO-FIT
   ***********************/
  function fitStage(){
    const stage = document.getElementById("stage");
    const module = document.getElementById("savySnakeModule");
    if (!stage || !module) return;

    const baseW = module.offsetWidth;
    const baseH = module.offsetHeight;

    stage.style.width = baseW + "px";
    stage.style.height = baseH + "px";

    const vw = window.innerWidth;
    const vh = window.innerHeight;

    const scale = Math.min(vw / baseW, vh / baseH);

    stage.style.transform = `scale(${scale})`;
    stage.style.left = Math.floor((vw - baseW * scale) / 2) + "px";
    stage.style.top  = Math.floor((vh - baseH * scale) / 2) + "px";
  }
  window.addEventListener("resize", fitStage);

  /***********************
   * CANVAS SETUP
   ***********************/
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha:true });
// prevent page scroll when swiping on the canvas (mobile)
["touchstart", "touchmove", "touchend"].forEach((evt) => {
  canvas.addEventListener(
    evt,
    (e) => e.preventDefault(),
    { passive: false }
  );
});

  // Keep snake crisp after any resize
  function setCrisp(){
    ctx.imageSmoothingEnabled = false;
    ctx.webkitImageSmoothingEnabled = false;
    ctx.mozImageSmoothingEnabled = false;
  }

  // Supersampled resize for better sharpness in Readymag scaling
  function resizeCanvasToBox(){
    const boxEl = canvas.parentElement;

    let cssW = boxEl.clientWidth;
    let cssH = boxEl.clientHeight;

    // fallback when layout reports 0
    if (!cssW || !cssH){
      const r = boxEl.getBoundingClientRect();
      cssW = Math.round(r.width);
      cssH = Math.round(r.height);
    }

    if (cssW < 2 || cssH < 2) return;

    const dpr = window.devicePixelRatio || 1;
    const SUPERSAMPLE = 2;
    const MAX_PX = 5000;

    const px = Math.min(MAX_PX, Math.floor(cssW * dpr * SUPERSAMPLE));
    const py = Math.min(MAX_PX, Math.floor(cssH * dpr * SUPERSAMPLE));

    if (px < 2 || py < 2) return;

    if (canvas.width !== px || canvas.height !== py){
      canvas.width = px;
      canvas.height = py;
      setCrisp();
    }
  }
  window.addEventListener("resize", resizeCanvasToBox);

  /***********************
   * UI
   ***********************/
  const scoreText = document.getElementById("scoreText");
  const enterShop = document.getElementById("enterShop");

  function setScoreUI(n){
    const s = String(n).padStart(2, "0");
    scoreText.textContent = `SCORE: ${s}`;
  }

  function unlockUI(){
    if (!enterShop.classList.contains("unlocked")){
      enterShop.classList.add("unlocked");
      enterShop.classList.remove("flash");
      void enterShop.offsetWidth;
      enterShop.classList.add("flash");
    }
  }

  enterShop.addEventListener("click", () => {
    if (!enterShop.classList.contains("unlocked")) return;
    if (SHOP_URL) window.location.href = SHOP_URL;
  });

  /***********************
   * FOOD LOGO
   ***********************/
  const foodImg = new Image();
  foodImg.decoding = "async";
  foodImg.src = LOGO_SRC;

  /***********************
   * GAME STATE
   ***********************/
  let snake = [];
  let dir = {x:1, y:0};
  let nextDir = {x:1, y:0};
  let food = {x:10, y:10};
  let score = 0;

  let tickMs = START_MS;
  let lastTime = 0;
  let acc = 0;
  let running = false;
  let dead = false;

  let unlockFlashT = 0;

  function cellSize(){
    return Math.floor(Math.min(canvas.width, canvas.height) / GRID);
  }

  function reset(){
    score = 0;
    setScoreUI(score);
    tickMs = START_MS;
    dead = false;
    unlockFlashT = 0;

    // reset timing for clean restart
    lastTime = 0;
    acc = 0;

    const mid = Math.floor(GRID/2);
    snake = [
      {x: mid,   y: mid},
      {x: mid-1, y: mid},
      {x: mid-2, y: mid},
      {x: mid-3, y: mid},
    ];
    dir = {x:1,y:0};
    nextDir = {x:1,y:0};
    food = spawnFood();
    enterShop.classList.remove("unlocked","flash");

    playSfx(startSfx);
  }

  function spawnFood(){
    for (let i=0; i<1200; i++){
      const x = Math.floor(Math.random()*GRID);
      const y = Math.floor(Math.random()*GRID);
      if (!snake.some(s => s.x===x && s.y===y)) return {x,y};
    }
    return {x:0,y:0};
  }

  function step(){
    if (dead) return;

    dir = nextDir;
    const head = snake[0];
    const nx = head.x + dir.x;
    const ny = head.y + dir.y;

    if (nx < 0 || ny < 0 || nx >= GRID || ny >= GRID){
  dead = true;
  playSfx(loseSfx);
  return;
}
  if (snake.some((s, idx) => idx!==0 && s.x===nx && s.y===ny)){
  dead = true;
  playSfx(loseSfx);
  return;
}

    snake.unshift({x:nx, y:ny});

    if (nx === food.x && ny === food.y){
      score += 1;
        playSfx(eatSfx);
      setScoreUI(score);

      if (score % SPEEDUP_EVERY === 0){
        tickMs = Math.max(MIN_MS, tickMs - SPEEDUP_MS);
      }

      if (score === UNLOCK_SCORE){
        unlockUI();
        unlockFlashT = 650;
          playSfx(unlockSfx);
      } else if (score > UNLOCK_SCORE){
        unlockUI();
      }

      if (score === DISCOUNT_SCORE){
          playSfx(unlockSfx);
        // later
      }

      food = spawnFood();
    } else {
      snake.pop();
    }
  }

  /***********************
   * DRAW
   ***********************/
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const cs = cellSize();

    // snake
    ctx.fillStyle = "#fff";
    for (let i=0; i<snake.length; i++){
      const s = snake[i];
      ctx.fillRect(s.x*cs + 1, s.y*cs + 1, cs - 2, cs - 2);
    }

    // food logo (smooth + explicitly re-enable smoothing for logo only)
    const fx = food.x * cs;
    const fy = food.y * cs;

    if (foodImg.complete && foodImg.naturalWidth){
      const target = cs * FOOD_SCALE_TO_CELL;

      const iw = foodImg.naturalWidth;
      const ih = foodImg.naturalHeight;
      const sc = Math.min(target / iw, target / ih);

      const dw = iw * sc;
      const dh = ih * sc;

      const dx = fx + (cs - dw)/2;
      const dy = fy + (cs - dh)/2;

      ctx.save();
      ctx.imageSmoothingEnabled = true;
      ctx.webkitImageSmoothingEnabled = true;
      ctx.mozImageSmoothingEnabled = true;
      ctx.drawImage(foodImg, dx, dy, dw, dh);
      ctx.restore();

      // restore pixel-crisp for snake blocks
      setCrisp();
    } else {
      ctx.fillStyle = "#fff";
      ctx.fillRect(fx + cs*0.35, fy + cs*0.35, cs*0.3, cs*0.3);
      ctx.fillStyle = "#fff";
    }

    // unlock pulse
    if (unlockFlashT > 0){
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = Math.max(4, Math.floor(cs*0.15));
      ctx.strokeRect(ctx.lineWidth/2, ctx.lineWidth/2, canvas.width-ctx.lineWidth, canvas.height-ctx.lineWidth);
      ctx.restore();
    }

    // game over text (space restart)
    if (dead){
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.font = `${Math.floor(canvas.width*0.055)}px "Source Sans Pro", Arial`;
      ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);

      ctx.font = `${Math.floor(canvas.width*0.028)}px "Source Sans Pro", Arial`;
      ctx.fillText("HIT SPACE TO TRY AGAIN", canvas.width/2, canvas.height/2 + Math.floor(canvas.width*0.07));

      ctx.restore();
    }
  }

  /***********************
   * LOOP
   ***********************/
  function loop(t){
    if (!lastTime) lastTime = t;
    const dt = t - lastTime;
    lastTime = t;

    // autoplay whenever not dead
    if (!dead) running = true;

    if (running && !dead){
      acc += dt;
      while (acc >= tickMs){
        step();
        acc -= tickMs;
      }
    }

    if (unlockFlashT > 0){
      unlockFlashT = Math.max(0, unlockFlashT - dt);
    }

    draw();
    requestAnimationFrame(loop);
  }

  /***********************
   * INPUT
   ***********************/
  function setDirection(dx, dy){
    if (dx === -dir.x && dy === -dir.y) return;
    nextDir = {x:dx,y:dy};
  }

  // Prevent page scrolling for arrows + space in iframes
  const blockKeys = new Set(["arrowup","arrowdown","arrowleft","arrowright"," "]);

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
        armAudioOnce();

    if (blockKeys.has(k)){
      e.preventDefault();
      e.stopPropagation();
    }

    // space = restart when dead
    if (k === " " && dead){
      reset();
      dead = false;
      running = true;
      return;
    }

    if (dead) return;

    if (k === "arrowup" || k === "w"){ setDirection(0,-1); }
    else if (k === "arrowdown" || k === "s"){ setDirection(0,1); }
    else if (k === "arrowleft" || k === "a"){ setDirection(-1,0); }
    else if (k === "arrowright" || k === "d"){ setDirection(1,0); }
  }, {passive:false});

  // touch swipe
  let sx=0, sy=0, touching=false;
  canvas.addEventListener("touchstart", (e) => {
   armAudioOnce();
    
    if (!e.touches || e.touches.length !== 1) return;
    touching = true;
    sx = e.touches[0].clientX;
    sy = e.touches[0].clientY;
  }, {passive:true});

  canvas.addEventListener("touchmove", (e) => {
    if (touching) e.preventDefault();
  }, {passive:false});

  canvas.addEventListener("touchend", (e) => {
    if (!touching) return;
    touching = false;

    const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
    if (!t) return;

    const dx = t.clientX - sx;
    const dy = t.clientY - sy;

    const adx = Math.abs(dx);
    const ady = Math.abs(dy);
    const threshold = 14;

    // tap = restart if dead
    if (adx < threshold && ady < threshold){
      if (dead){
        reset();
        dead = false;
        running = true;
      }
      return;
    }

    if (dead) return;

    if (adx > ady){
      setDirection(dx > 0 ? 1 : -1, 0);
    } else {
      setDirection(0, dy > 0 ? 1 : -1);
    }
  }, {passive:true});

  /***********************
   * INIT
   ***********************/
  async function init(){
    try{
      if (document.fonts && document.fonts.load){
        await document.fonts.load('600 24px "Source Sans Pro"');
      }
    } catch (_) {}

    fitStage();
    resizeCanvasToBox();

    // double frame helps layout settle (prevents 0-size issues)
    requestAnimationFrame(() => {
      fitStage();
      resizeCanvasToBox();
      requestAnimationFrame(() => {
        fitStage();
        resizeCanvasToBox();
      });
    });

    reset();
    running = true; // autoplay on load
    setCrisp();

    requestAnimationFrame(loop);
  }

  if (document.readyState === "loading"){
    window.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
})();
</script>

</body>
</html>
