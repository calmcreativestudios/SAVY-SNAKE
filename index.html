<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Savy Snake Module</title>

  <!-- Source Sans Pro -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;600&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#ffffff;
      --ink:#000000;
      --game:#000000;
      --ui:#000000;

      /* Layout sizing (the “design canvas” size) */
      --gameSize: 900px;    /* change to 800px if you want later */
      --gap: 48px;
      --sideMin: 220px;
    }

    html,body{
      margin:0; padding:0;
      width:100%;
      height:100%;
      background:var(--bg);
      color:var(--ui);
      font-family:"Source Sans Pro",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      overflow:hidden; /* critical for iframe embedding + scaling */
    }

    /* This is the scaled stage that makes Readymag editor/preview consistent */
    #stage{
      position:fixed;
      left:0;
      top:0;
      transform-origin: 0 0;
      will-change: transform;
      /* width/height are set by JS based on actual content size */
    }

    /* MODULE */
    .savy-snake{
      display:flex;
      align-items:flex-start;
      gap:var(--gap);
      background:transparent;
    }

    /* GAME BOX */
    .gameBox{
      width:var(--gameSize);
      height:var(--gameSize);
      background:var(--game);
      border:6px solid var(--ink);
      box-sizing:border-box;
      display:grid;
      place-items:center;
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
      background:transparent;
      image-rendering: pixelated; /* snake pixels */
      touch-action:none; /* prevent page scroll on mobile while swiping */
    }

    /* RIGHT UI */
    .sideUI{
      min-width:var(--sideMin);
      padding-top:8px;
      user-select:none;
    }

    .score{
      font-size:16px;
      letter-spacing:0.5px;
      text-transform:uppercase;
      font-weight:400;
    }

    .enterShop{
      margin-top:44px;
      font-size:16px;
      letter-spacing:0.5px;
      text-transform:uppercase;
      font-weight:400;
      opacity:0;
      pointer-events:none;
      transition:opacity 180ms linear;
      cursor:pointer;
      display:inline-block;
    }

    .enterShop.unlocked{
      opacity:1;
      pointer-events:auto;
    }

    /* subtle flash on unlock */
    .enterShop.flash{ animation: flash 0.65s linear 1; }
    @keyframes flash{
      0%{opacity:0.15;}
      12%{opacity:1;}
      24%{opacity:0.15;}
      36%{opacity:1;}
      48%{opacity:0.15;}
      60%{opacity:1;}
      100%{opacity:1;}
    }
  </style>
</head>
<body>

  <!-- Stage wrapper (scaled to fit any iframe size) -->
  <div id="stage">
    <div class="savy-snake" id="savySnakeModule">
      <div class="gameBox" aria-label="Savy Snake game">
        <canvas id="game" width="900" height="900"></canvas>
      </div>

      <div class="sideUI">
        <div class="score" id="scoreText">SCORE: 00</div>
        <div class="enterShop" id="enterShop">ENTER SHOP</div>
      </div>
    </div>
  </div>

<script>
(() => {
  /***********************
   * SETTINGS YOU EDIT
   ***********************/
  const UNLOCK_SCORE = 22;
  const DISCOUNT_SCORE = 100; // later
  const SHOP_URL = ""; // set to your shop URL later

  // Game feel (faster)
  const GRID = 28;
  const START_MS = 80;
  const MIN_MS = 52;
  const SPEEDUP_EVERY = 4;
  const SPEEDUP_MS = 4;

  // Food (logo) sizing (bigger than tile so it’s visible)
  const FOOD_SCALE_TO_CELL = 1.6;

  // SVG file in repo root (must exist): savy-logo.svg
  const LOGO_SRC = "./savy-logo.svg";

  /***********************
   * STAGE AUTO-FIT (KEY FIX FOR READYMAG)
   * Makes editor and preview/published match by scaling to viewport.
   ***********************/
  function fitStage(){
    const stage = document.getElementById("stage");
    const module = document.getElementById("savySnakeModule");
    if (!stage || !module) return;

    // Measure actual designed size
    const baseW = module.offsetWidth;
    const baseH = module.offsetHeight;

    // Lock stage box to that size
    stage.style.width = baseW + "px";
    stage.style.height = baseH + "px";

    // Fit into iframe/viewport
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    const scale = Math.min(1, vw / baseW, vh / baseH);

    stage.style.transform = `scale(${scale})`;

    // Center
    const left = Math.floor((vw - baseW * scale) / 2);
    const top  = Math.floor((vh - baseH * scale) / 2);
    stage.style.left = left + "px";
    stage.style.top  = top + "px";
  }

  window.addEventListener("resize", fitStage);

  /***********************
   * CANVAS SETUP
   ***********************/
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha:true });

  function setCrisp(){
    // crisp snake blocks
    ctx.imageSmoothingEnabled = false;
    ctx.webkitImageSmoothingEnabled = false;
    ctx.mozImageSmoothingEnabled = false;
  }

  // Make internal canvas resolution match its displayed size (keeps pixels crisp)
function resizeCanvasToBox(){
  // Use layout size (not getBoundingClientRect) because Readymag may scale via transforms
  const boxEl = canvas.parentElement;
  const cssW = boxEl.clientWidth;
  const cssH = boxEl.clientHeight;

  // Render extra pixels for sharpness (supersampling)
  const dpr = (window.devicePixelRatio || 1);
  const SUPERSAMPLE = 2; // try 2 first. If still soft, try 3 (heavier)

  // Cap to avoid insane GPU load
  const MAX_PX = 5000;

  const px = Math.min(MAX_PX, Math.floor(cssW * dpr * SUPERSAMPLE));
  const py = Math.min(MAX_PX, Math.floor(cssH * dpr * SUPERSAMPLE));

  if (canvas.width !== px || canvas.height !== py){
    canvas.width = px;
    canvas.height = py;
    setCrisp();
  }
}
    }
  }
  window.addEventListener("resize", resizeCanvasToBox);

  /***********************
   * UI
   ***********************/
  const scoreText = document.getElementById("scoreText");
  const enterShop = document.getElementById("enterShop");

  function setScoreUI(n){
    const s = String(n).padStart(2, "0");
    scoreText.textContent = `SCORE: ${s}`;
  }

  function unlockUI(){
    if (!enterShop.classList.contains("unlocked")){
      enterShop.classList.add("unlocked");
      enterShop.classList.remove("flash");
      void enterShop.offsetWidth;
      enterShop.classList.add("flash");
    }
  }

  enterShop.addEventListener("click", () => {
    if (!enterShop.classList.contains("unlocked")) return;
    if (SHOP_URL) window.location.href = SHOP_URL;
  });

  /***********************
   * FOOD LOGO IMAGE
   ***********************/
  const foodImg = new Image();
  foodImg.decoding = "async";
  foodImg.src = LOGO_SRC;

  /***********************
   * GAME STATE
   ***********************/
  let snake = [];
  let dir = {x:1, y:0};
  let nextDir = {x:1, y:0};
  let food = {x:10, y:10};
  let score = 0;

  let tickMs = START_MS;
  let lastTime = 0;
  let acc = 0;
  let running = false;
  let dead = false;

  let unlockFlashT = 0;

  function cellSize(){
    return Math.floor(Math.min(canvas.width, canvas.height) / GRID);
  }

  function reset(){
    score = 0;
    setScoreUI(score);
    tickMs = START_MS;
    dead = false;
    unlockFlashT = 0;

    // timing reset to avoid a “burst” after restart
    lastTime = 0;
    acc = 0;

    const mid = Math.floor(GRID/2);
    snake = [
      {x: mid,   y: mid},
      {x: mid-1, y: mid},
      {x: mid-2, y: mid},
      {x: mid-3, y: mid},
    ];
    dir = {x:1,y:0};
    nextDir = {x:1,y:0};
    food = spawnFood();
    enterShop.classList.remove("unlocked","flash");
  }

  function spawnFood(){
    for (let i=0; i<1200; i++){
      const x = Math.floor(Math.random()*GRID);
      const y = Math.floor(Math.random()*GRID);
      if (!snake.some(s => s.x===x && s.y===y)) return {x,y};
    }
    return {x:0,y:0};
  }

  function step(){
    if (dead) return;

    dir = nextDir;
    const head = snake[0];
    const nx = head.x + dir.x;
    const ny = head.y + dir.y;

    if (nx < 0 || ny < 0 || nx >= GRID || ny >= GRID){
      dead = true; return;
    }
    if (snake.some((s, idx) => idx!==0 && s.x===nx && s.y===ny)){
      dead = true; return;
    }

    snake.unshift({x:nx, y:ny});

    if (nx === food.x && ny === food.y){
      score += 1;
      setScoreUI(score);

      if (score % SPEEDUP_EVERY === 0){
        tickMs = Math.max(MIN_MS, tickMs - SPEEDUP_MS);
      }

      if (score === UNLOCK_SCORE){
        unlockUI();
        unlockFlashT = 650;
      } else if (score > UNLOCK_SCORE){
        unlockUI();
      }

      if (score === DISCOUNT_SCORE){
        // placeholder hook for discount later
      }

      food = spawnFood();
    } else {
      snake.pop();
    }
  }

  /***********************
   * DRAW
   ***********************/
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const cs = cellSize();

    // snake (white blocks)
    ctx.fillStyle = "#fff";
    for (let i=0; i<snake.length; i++){
      const s = snake[i];
      const x = s.x * cs;
      const y = s.y * cs;
      ctx.fillRect(x + 1, y + 1, cs - 2, cs - 2);
    }

    // food (smooth logo)
    const fx = food.x * cs;
    const fy = food.y * cs;

    if (foodImg.complete && foodImg.naturalWidth){
      const target = cs * FOOD_SCALE_TO_CELL;

      const iw = foodImg.naturalWidth;
      const ih = foodImg.naturalHeight;
      const scale = Math.min(target / iw, target / ih);

      const dw = iw * scale;
      const dh = ih * scale;

      const dx = fx + (cs - dw)/2;
      const dy = fy + (cs - dh)/2;

      ctx.save();
      ctx.imageSmoothingEnabled = true; // keep logo smooth
      ctx.drawImage(foodImg, dx, dy, dw, dh);
      ctx.restore();

      setCrisp();
    } else {
      // fallback square
      ctx.fillStyle = "#fff";
      ctx.fillRect(fx + cs*0.35, fy + cs*0.35, cs*0.3, cs*0.3);
      ctx.fillStyle = "#fff";
    }

    // subtle border pulse on unlock
    if (unlockFlashT > 0){
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = Math.max(4, Math.floor(cs*0.15));
      ctx.strokeRect(ctx.lineWidth/2, ctx.lineWidth/2, canvas.width-ctx.lineWidth, canvas.height-ctx.lineWidth);
      ctx.restore();
    }

    // death state — UPDATED COPY + SPACE RESTART
    if (dead){
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#000";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.font = `${Math.floor(canvas.width*0.055)}px "Source Sans Pro", Arial`;
      ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);

      ctx.font = `${Math.floor(canvas.width*0.028)}px "Source Sans Pro", Arial`;
      ctx.fillText("HIT SPACE TO TRY AGAIN", canvas.width/2, canvas.height/2 + Math.floor(canvas.width*0.07));

      ctx.restore();
    }
  }

  /***********************
   * LOOP
   ***********************/
  function loop(t){
    if (!lastTime) lastTime = t;
    const dt = t - lastTime;
    lastTime = t;

    // AUTOPLAY: game runs whenever not dead
    if (!dead){
      running = true;
    }

    if (running && !dead){
      acc += dt;
      while (acc >= tickMs){
        step();
        acc -= tickMs;
      }
    }

    if (unlockFlashT > 0){
      unlockFlashT = Math.max(0, unlockFlashT - dt);
    }

    draw();
    requestAnimationFrame(loop);
  }

  /***********************
   * INPUT
   ***********************/
  function setDirection(dx, dy){
    if (dx === -dir.x && dy === -dir.y) return;
    nextDir = {x:dx,y:dy};
  }

  // Prevent page scrolling for arrows + space in iframes
  const blockKeys = new Set(["arrowup","arrowdown","arrowleft","arrowright"," "]);

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();

    if (blockKeys.has(k)){
      e.preventDefault();
      e.stopPropagation();
    }

    // SPACE = restart when dead
    if (k === " " && dead){
      reset();
      dead = false;
      running = true;
      return;
    }

    if (dead) return;

    if (k === "arrowup" || k === "w"){ setDirection(0,-1); }
    else if (k === "arrowdown" || k === "s"){ setDirection(0,1); }
    else if (k === "arrowleft" || k === "a"){ setDirection(-1,0); }
    else if (k === "arrowright" || k === "d"){ setDirection(1,0); }
  }, {passive:false});

  // touch swipe
  let sx=0, sy=0, touching=false;
  canvas.addEventListener("touchstart", (e) => {
    if (!e.touches || e.touches.length !== 1) return;
    touching = true;
    sx = e.touches[0].clientX;
    sy = e.touches[0].clientY;
  }, {passive:true});

  canvas.addEventListener("touchmove", (e) => {
    if (touching) e.preventDefault();
  }, {passive:false});

  canvas.addEventListener("touchend", (e) => {
    if (!touching) return;
    touching = false;

    const t = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0] : null;
    if (!t) return;

    const dx = t.clientX - sx;
    const dy = t.clientY - sy;

    const adx = Math.abs(dx);
    const ady = Math.abs(dy);
    const threshold = 14;

    // tap = restart when dead
    if (adx < threshold && ady < threshold){
      if (dead){
        reset();
        dead = false;
        running = true;
      }
      return;
    }

    if (dead) return;

    if (adx > ady){
      setDirection(dx > 0 ? 1 : -1, 0);
    } else {
      setDirection(0, dy > 0 ? 1 : -1);
    }
  }, {passive:true});

  /***********************
   * INIT
   ***********************/
  async function init(){
    try{
      if (document.fonts && document.fonts.load){
        await document.fonts.load('600 24px "Source Sans Pro"');
      }
    } catch (_) {}

    fitStage();
    resizeCanvasToBox();

    requestAnimationFrame(() => {
      fitStage();
      resizeCanvasToBox();
    });

    reset();

    // AUTOPLAY ON LOAD
    running = true;

    setCrisp();
    requestAnimationFrame(loop);
  }

  if (document.readyState === "loading"){
    window.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
})();
</script>

</body>
</html>
